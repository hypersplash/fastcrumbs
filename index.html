<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Calculator — Optimized</title>
  <style>
    /* Minimal, high-contrast UI (keeps the original look) */
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      background:#000;color:#fff;display:flex;align-items:center;justify-content:center;padding:20px;
    }
    .container{width:100%;max-width:640px;padding:18px}
    .history{
      max-height:320px;overflow:auto;margin-bottom:12px;padding:10px;border:2px solid #fff;background:transparent;font-size:15px;
    }
    .history-item{padding:8px 0;border-bottom:1px solid #222}
    .expr{color:#fff}
    .result{color:#fff;font-weight:600}
    .error{color:#ff6b6b}
    input[type="text"]{
      width:100%;padding:12px;font-family:inherit;font-size:16px;background:#000;color:#fff;border:2px solid #fff;outline:none
    }
    input[type="text"]:focus{border-color:#fff}
    @media (prefers-reduced-motion:reduce){*{transition:none!important}}
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Calculator">
    <div id="history" class="history" aria-live="polite"></div>
    <input id="input" type="text" inputmode="numeric" autocomplete="off" placeholder="Type expression and press Enter — e.g. sqrt(16)" aria-label="Expression input" />
  </div>

  <script defer>
  // === Modern, commented, and optimized calculator script ===
  // Goals: clearer comments, fewer global ops, faster replacements, small cache, safer eval.

  (function () {
    'use strict';

    // Elements (cached once)
    const inp = document.getElementById('input');
    const hist = document.getElementById('history');

    // Math utility collection. Keep mutability only where needed (ans).
    const mathFns = {
      // constants
      pi: Math.PI,
      e: Math.E,
      ans: 0,

      // basic
      abs: Math.abs,
      sqrt: Math.sqrt,
      cbrt: Math.cbrt,
      exp: Math.exp,
      ln: Math.log,
      lb: Math.log2,
      lg: Math.log10,
      log: (base, x) => Math.log(x) / Math.log(base),
      sgn: x => (x === 0 ? 0 : x > 0 ? 1 : -1),
      int: Math.trunc,
      frac: x => x - Math.trunc(x),

      // trig
      sin: Math.sin,
      cos: Math.cos,
      tan: Math.tan,
      cot: x => 1 / Math.tan(x),
      sec: x => 1 / Math.cos(x),
      csc: x => 1 / Math.sin(x),
      arcsin: Math.asin,
      arccos: Math.acos,
      arctan: Math.atan,
      arctan2: Math.atan2,

      // hyperbolic
      sinh: Math.sinh,
      cosh: Math.cosh,
      tanh: Math.tanh,
      arsinh: Math.asinh,
      arcosh: Math.acosh,
      artanh: Math.atanh,

      // rounding
      floor: Math.floor,
      ceil: Math.ceil,
      round: (x, d = 0) => Math.round(x * Math.pow(10, d)) / Math.pow(10, d),
      trunc: (x, d = 0) => Math.trunc(x * Math.pow(10, d)) / Math.pow(10, d),

      // integer
      idiv: (x, y) => Math.trunc(x / y),
      mod: (x, y) => ((x % y) + y) % y,

      // combinatorics
      ncr: (n, k) => {
        if (k > n) return 0; if (k === 0 || k === n) return 1;
        let r = 1; for (let i = 1; i <= k; i++) r *= (n - k + i) / i; return r;
      },
      npr: (n, k) => { let r = 1; for (let i = 0; i < k; i++) r *= (n - i); return r; },

      // statistics
      sum: (...a) => a.reduce((s, v) => s + v, 0),
      product: (...a) => a.reduce((s, v) => s * v, 1),
      average: (...a) => a.length ? mathFns.sum(...a) / a.length : NaN,
      min: Math.min, max: Math.max,

      // gamma & factorial (better accuracy via Lanczos approximation - kept compact)
      gamma: (function () {
        const lanczos = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,
          771.32342877765313, -176.61502916214059, 12.507343278686905,
          -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
        return function gamma(z) {
          if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
          z -= 1; const g = 7; let a = lanczos[0];
          for (let i = 1; i < lanczos.length; i++) a += lanczos[i] / (z + i);
          const t = z + g + 0.5;
          return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * a;
        };
      })(),
      fact: n => mathFns.gamma(n + 1),

      // formatting helpers
      bin: x => '0b' + Math.trunc(x).toString(2),
      oct: x => '0o' + Math.trunc(x).toString(8),
      hex: x => '0x' + Math.trunc(x).toString(16),
      dec: x => parseInt(x, 10)
    };

    // Precompute function-name regex to speed replacements (runs once)
    const fnNames = Object.keys(mathFns).sort((a, b) => b.length - a.length); // longest first
    const fnRegex = new RegExp('\\b(' + fnNames.map(escapeRegExp).join('|') + ')\\s*\\(', 'g');

    // Small LRU-ish cache for compiled expressions to avoid reparsing identical inputs
    const cache = new Map();
    const CACHE_LIMIT = 200;

    // Disallowed tokens (very lightweight sandbox) — block obviously dangerous globals
    const blacklist = /\b(window|document|fetch|XMLHttpRequest|navigator|process|require|import|globalThis|Function|eval)\b/;

    // Utility: escape regex metacharacters
    function escapeRegExp(s) {
      return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    // Primary evaluator
    function evalExpr(raw) {
      // Normalize whitespace and replace semicolon argument separators with commas (user convenience)
      const expr = raw.trim().replace(/\u00A0/g, ' ').replace(/\s*;\s*/g, ',');
      if (!expr) return { ok: false, err: 'empty' };

      // Quick blacklist check
      if (blacklist.test(expr)) return { ok: false, err: 'forbidden token' };

      // Use cache if available
      if (cache.has(expr)) {
        try {
          const compiled = cache.get(expr);
          const res = compiled(mathFns);
          if (!Number.isFinite(res) && typeof res !== 'object') {
            // allow non-numeric like arrays/objects from helpers but still show them
          }
          mathFns.ans = res;
          return { ok: true, val: res };
        } catch (e) {
          cache.delete(expr); // remove bad cache entry
          return { ok: false, err: e.message };
        }
      }

      // Prepare a sanitized, JS-friendly string for evaluation.
      // - Replace '^' with '**'
      // - Replace 'pi'/'e'/'ans' with mathFns.* so they bind correctly
      // - Replace function calls like sin( -> mathFns.sin(
      // - Replace trailing factorial n! -> mathFns.fact(n)
      let proc = expr.replace(/\^/g, '**')
                     .replace(/\bpi\b/gi, 'mathFns.pi')
                     .replace(/\be\b(?![\w])/gi, 'mathFns.e')
                     .replace(/\bans\b/gi, 'mathFns.ans')
                     // generic replacement of function names -> mathFns.<name>(
                     .replace(fnRegex, 'mathFns.$1(')
                     // factorial:  number!  (supports integers). Uses function call to preserve accuracy
                     .replace(/(\d+(?:\.\d+)?)!/g, 'mathFns.fact($1)')
                     // percent: 50% -> (50/100)
                     .replace(/(\d+(?:\.\d+)?)%/g, '($1/100)');

      // Compile into a Function once, then cache the compiled function for reuse.
      // Wrapping in a function keeps the global scope clean and gives access only to mathFns.
      let compiled;
      try {
        // Small additional safety: make expression a single return statement
        compiled = new Function('mathFns', `"use strict"; return (${proc});`);

        // Add to cache (evict oldest when full)
        cache.set(expr, compiled);
        if (cache.size > CACHE_LIMIT) {
          const firstKey = cache.keys().next().value;
          cache.delete(firstKey);
        }

        const val = compiled(mathFns);
        mathFns.ans = val;
        return { ok: true, val };
      } catch (err) {
        return { ok: false, err: err.message };
      }
    }

    // Append history efficiently
    function addHistory(expr, res) {
      const frag = document.createDocumentFragment();
      const item = document.createElement('div');
      item.className = 'history-item';

      if (res.ok) {
        const resultText = (typeof res.val === 'number') ? String(res.val) : JSON.stringify(res.val);
        item.innerHTML = `<div class="expr">${escapeHtml(expr)}</div><div class="result">= ${escapeHtml(resultText)}</div>`;
      } else {
        item.innerHTML = `<div class="expr">${escapeHtml(expr)}</div><div class="error">Error: ${escapeHtml(res.err)}</div>`;
      }

      frag.appendChild(item);
      hist.appendChild(frag);
      // scroll into view using rAF for smoother experience
      requestAnimationFrame(() => { hist.scrollTop = hist.scrollHeight; });
    }

    // Utility: simple HTML escape to avoid XSS in history display
    function escapeHtml(s) {
      return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // Help content (kept short; UI shows full help on demand)
    function showHelp() {
      const help = `Type expressions using standard math operators and functions from the built-in library. Examples:\nsqrt(16)  sin(pi/2)  5!  50%  ncr(10,3)`;
      const item = document.createElement('div');
      item.className = 'history-item';
      item.innerHTML = `<div class="expr">help</div><div style="color:#fff;margin-top:8px;white-space:pre-wrap">${escapeHtml(help)}</div>`;
      hist.appendChild(item);
      requestAnimationFrame(() => { hist.scrollTop = hist.scrollHeight; });
    }

    // Keyboard handler — only reacts to Enter (kept intentionally minimal)
    inp.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter') {
        const raw = inp.value;
        if (!raw) return;
        if (raw.trim().toLowerCase() === 'help') { showHelp(); inp.value = ''; return; }

        const res = evalExpr(raw);
        addHistory(raw, res);
        inp.value = '';
      }
    });

    // Focus the input on load for convenience
    window.addEventListener('load', () => inp.focus());

    // Expose a tiny debugging hook when running locally (only if developer console used)
    try { window.__calc = { evalExpr, mathFns }; } catch (e) { /* noop in strict embed */ }

  })();
  </script>
</body>
</html>
