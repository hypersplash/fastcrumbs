<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>fastcrumbs</title>
  <style>
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      background:#000;color:#fff;display:flex;align-items:center;justify-content:center;padding:20px;
    }
    .container{width:100%;max-width:640px;padding:18px}
    .history{max-height:320px;overflow:auto;margin-bottom:12px;padding:10px;border:2px solid #fff;background:transparent;font-size:15px}
    .history-item{padding:8px 0;border-bottom:1px solid #222}
    .expr{color:#fff}
    .result{color:#fff;font-weight:600}
    .error{color:#ff6b6b}
    input[type="text"]{width:100%;padding:12px;font-family:inherit;font-size:16px;background:#000;color:#fff;border:2px solid #fff;outline:none}
    input[type="text"]:focus{border-color:#fff}
    @media (prefers-reduced-motion:reduce){*{transition:none!important}}
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Calculator">
    <div id="history" class="history" aria-live="polite"></div>
    <!-- Full keyboard on mobile: use inputmode="text" instead of numeric -->
    <input id="input" type="text" inputmode="text" autocomplete="off" placeholder="Type expression and press Enter — e.g. sqrt(16)" aria-label="Expression input" />
  </div>

  <script defer>
  (function () {
    'use strict';

    const inp = document.getElementById('input');
    const hist = document.getElementById('history');

    const mathFns = {
      pi: Math.PI,
      e: Math.E,
      ans: 0,
      abs: Math.abs,
      sqrt: Math.sqrt,
      cbrt: Math.cbrt,
      exp: Math.exp,
      ln: Math.log,
      lb: Math.log2,
      lg: Math.log10,
      log: (base, x) => Math.log(x) / Math.log(base),
      sgn: x => (x === 0 ? 0 : x > 0 ? 1 : -1),
      int: Math.trunc,
      frac: x => x - Math.trunc(x),
      sin: Math.sin,
      cos: Math.cos,
      tan: Math.tan,
      cot: x => 1 / Math.tan(x),
      sec: x => 1 / Math.cos(x),
      csc: x => 1 / Math.sin(x),
      arcsin: Math.asin,
      arccos: Math.acos,
      arctan: Math.atan,
      arctan2: Math.atan2,
      sinh: Math.sinh,
      cosh: Math.cosh,
      tanh: Math.tanh,
      arsinh: Math.asinh,
      arcosh: Math.acosh,
      artanh: Math.atanh,
      floor: Math.floor,
      ceil: Math.ceil,
      round: (x, d = 0) => Math.round(x * Math.pow(10, d)) / Math.pow(10, d),
      trunc: (x, d = 0) => Math.trunc(x * Math.pow(10, d)) / Math.pow(10, d),
      idiv: (x, y) => Math.trunc(x / y),
      mod: (x, y) => ((x % y) + y) % y,
      ncr: (n, k) => { if (k > n) return 0; if (k === 0 || k === n) return 1; let r = 1; for (let i = 1; i <= k; i++) r *= (n - k + i) / i; return r; },
      npr: (n, k) => { let r = 1; for (let i = 0; i < k; i++) r *= (n - i); return r; },
      sum: (...a) => a.reduce((s, v) => s + v, 0),
      product: (...a) => a.reduce((s, v) => s * v, 1),
      average: (...a) => a.length ? mathFns.sum(...a) / a.length : NaN,
      min: Math.min,
      max: Math.max,
      gamma: (function () {
        const lanczos = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
        return function gamma(z) {
          if (z < 0.5) return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
          z -= 1; const g = 7; let a = lanczos[0];
          for (let i = 1; i < lanczos.length; i++) a += lanczos[i] / (z + i);
          const t = z + g + 0.5;
          return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * a;
        };
      })(),
      fact: n => mathFns.gamma(n + 1),
      bin: x => '0b' + Math.trunc(x).toString(2),
      oct: x => '0o' + Math.trunc(x).toString(8),
      hex: x => '0x' + Math.trunc(x).toString(16),
      dec: x => parseInt(x, 10)
    };

    const fnNames = Object.keys(mathFns).sort((a, b) => b.length - a.length);
    const fnRegex = new RegExp('\\b(' + fnNames.map(s => s.replace(/[.*+?^${}()|[\\]\\]/g, '\\$&')).join('|') + ')\\s*\\(', 'g');
    const cache = new Map();
    const blacklist = /\b(window|document|fetch|XMLHttpRequest|navigator|process|require|import|globalThis|Function|eval)\b/;

    function evalExpr(raw) {
      const expr = raw.trim().replace(/\u00A0/g, ' ').replace(/\s*;\s*/g, ',');
      if (!expr) return { ok: false, err: 'empty' };
      if (blacklist.test(expr)) return { ok: false, err: 'forbidden token' };
      if (cache.has(expr)) {
        try {
          const compiled = cache.get(expr);
          const res = compiled(mathFns);
          mathFns.ans = res;
          return { ok: true, val: res };
        } catch (e) {
          cache.delete(expr);
          return { ok: false, err: e.message };
        }
      }
      let proc = expr.replace(/\^/g, '**')
        .replace(/\bpi\b/gi, 'mathFns.pi')
        .replace(/\be\b(?![\w])/gi, 'mathFns.e')
        .replace(/\bans\b/gi, 'mathFns.ans')
        .replace(fnRegex, 'mathFns.$1(')
        .replace(/(\d+(?:\.\d+)?)!/g, 'mathFns.fact($1)')
        .replace(/(\d+(?:\.\d+)?)%/g, '($1/100)');
      try {
        const compiled = new Function('mathFns', `"use strict"; return (${proc});`);
        cache.set(expr, compiled);
        const val = compiled(mathFns);
        mathFns.ans = val;
        return { ok: true, val };
      } catch (err) {
        return { ok: false, err: err.message };
      }
    }

    function addHistory(expr, res) {
      const item = document.createElement('div');
      item.className = 'history-item';
      if (res.ok) {
        const resultText = typeof res.val === 'number' ? String(res.val) : JSON.stringify(res.val);
        item.innerHTML = `<div class="expr">${expr}</div><div class="result">= ${resultText}</div>`;
      } else {
        item.innerHTML = `<div class="expr">${expr}</div><div class="error">Error: ${res.err}</div>`;
      }
      hist.appendChild(item);
      requestAnimationFrame(() => { hist.scrollTop = hist.scrollHeight; });
    }

    function showHelp() {
      const item = document.createElement('div');
      item.className = 'history-item';
      let html = '<div class="expr">help</div><div style="color:#fff;margin-top:8px;line-height:1.5">';
      fnNames.forEach(fn => {
        const ex = typeof mathFns[fn] === 'function' ? `<code>${fn}(…)</code>` : `<code>${fn}</code>`;
        html += `${ex}<br>`;
      });
      html += '</div>';
      item.innerHTML = html;
      hist.appendChild(item);
      requestAnimationFrame(() => { hist.scrollTop = hist.scrollHeight; });
    }

    inp.addEventListener('keydown', ev => {
      if (ev.key === 'Enter') {
        const raw = inp.value;
        if (!raw) return;
        if (raw.trim().toLowerCase() === 'help') { showHelp(); inp.value = ''; return; }
        const res = evalExpr(raw);
        addHistory(raw, res);
        inp.value = '';
      }
    });

    window.addEventListener('load', () => inp.focus());
  })();
  </script>
</body>
</html>
